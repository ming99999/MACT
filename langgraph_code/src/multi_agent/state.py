"""
Extended state definitions for Multi-Agent framework.

This module extends the original MACTState with additional fields
for EDA Agent and Report Generator outputs.
"""

from typing import TypedDict, List, Dict, Any, Optional, Literal
import sys
import os

# Add parent directory to path for importing mact_langgraph
sys.path.insert(0, os.path.join(os.path.dirname(__file__), '..'))

from mact_langgraph.state import MACTState, TableInfo


# Output format types for Report Generator
OutputFormat = Literal[
    "mmqa_json",        # MMQA dataset format: {answer, FK, PK, SQL}
    "business_report",  # Natural language report with reasoning
    "research_detailed", # Detailed execution log with tokens
    "simple_answer"     # Just the answer string
]


class MultiAgentState(MACTState):
    """
    Extended state schema for Multi-Agent framework.

    Adds EDA Agent and Report Generator specific fields to the base MACTState.
    """

    # ============================================
    # EDA Agent Outputs
    # ============================================

    eda_context: str
    """Natural language context generated by EDA Agent describing tables and relationships."""

    table_statistics: Dict[str, Any]
    """
    Statistical analysis of tables.
    Format: {
        "table_name": {
            "num_rows": int,
            "num_columns": int,
            "columns": {
                "col_name": {
                    "type": str,
                    "null_ratio": float,
                    "unique_count": int,
                    "sample_values": List[Any],
                    "value_distribution": Dict[str, int]  # for categorical
                }
            }
        }
    }
    """

    detected_foreign_keys: List[str]
    """
    Foreign key relationships detected by EDA Agent.
    Format: ["table1.col1 = table2.col2", ...]
    """

    column_types: Dict[str, Dict[str, str]]
    """
    Inferred column types for each table.
    Format: {"table_name": {"col_name": "numeric|categorical|datetime|text"}}
    """

    value_patterns: Dict[str, Any]
    """
    Detected patterns in values (date ranges, numeric ranges, categories).
    Format: {
        "table_name": {
            "col_name": {
                "pattern_type": "range|enum|date_range",
                "details": {...}
            }
        }
    }
    """

    # ============================================
    # Report Generator Outputs
    # ============================================

    output_format: str
    """Desired output format (mmqa_json|business_report|research_detailed|simple_answer)."""

    reasoning_report: str
    """Natural language summary of the reasoning process."""

    confidence_breakdown: Dict[str, float]
    """
    Confidence scores for different aspects.
    Format: {
        "overall": float,
        "answer_consensus": float,
        "code_execution": float,
        "reasoning_coherence": float
    }
    """

    formatted_output: Dict[str, Any]
    """
    Final formatted output according to output_format specification.
    For mmqa_json: {"answer": str, "foreign_keys": List[str], "primary_keys": List[str], "sql": str}
    For business_report: {"report": str, "answer": str, "confidence": float}
    For research_detailed: {full execution details}
    For simple_answer: {"answer": str}
    """


def create_multi_agent_initial_state(
    question: str,
    tables_data: List[Dict[str, Any]],
    table_names: List[str] = None,
    foreign_keys: List[str] = None,
    primary_keys: List[str] = None,
    context: str = "",
    output_format: str = "simple_answer",
    config: Dict[str, Any] = None
) -> MultiAgentState:
    """
    Create initial state for Multi-Agent graph execution.

    Args:
        question: The question to answer
        tables_data: List of table data dictionaries
        table_names: Names of the tables (optional)
        foreign_keys: Foreign key relationships (optional, will be auto-detected)
        primary_keys: Primary key information (optional, will be auto-detected)
        context: Additional context information
        output_format: Desired output format
        config: Configuration dictionary

    Returns:
        Initial MultiAgentState
    """
    from mact_langgraph.state import create_initial_state

    if config is None:
        config = {}

    # Create base MACT state
    base_state = create_initial_state(
        question=question,
        tables_data=tables_data,
        table_names=table_names,
        foreign_keys=foreign_keys,
        primary_keys=primary_keys,
        context=context,
        config=config
    )

    # Extend with multi-agent specific fields
    multi_agent_state = MultiAgentState(
        **base_state,

        # EDA Agent fields (to be populated)
        eda_context="",
        table_statistics={},
        detected_foreign_keys=[],
        column_types={},
        value_patterns={},

        # Report Generator fields
        output_format=output_format,
        reasoning_report="",
        confidence_breakdown={
            "overall": 0.0,
            "answer_consensus": 0.0,
            "code_execution": 0.0,
            "reasoning_coherence": 0.0
        },
        formatted_output={}
    )

    return multi_agent_state


def get_eda_context_summary(state: MultiAgentState) -> str:
    """
    Get a concise summary of EDA context for including in prompts.

    Args:
        state: Current multi-agent state

    Returns:
        Summary string suitable for prompt inclusion
    """
    if not state.get("eda_context"):
        return ""

    summary_parts = []

    # Add EDA context
    if state["eda_context"]:
        summary_parts.append(f"Table Analysis:\n{state['eda_context']}")

    # Add detected foreign keys if any
    if state.get("detected_foreign_keys"):
        fk_str = ", ".join(state["detected_foreign_keys"])
        summary_parts.append(f"\nDetected Relationships: {fk_str}")

    # Add key statistics
    if state.get("table_statistics"):
        stats_summary = []
        for table_name, stats in state["table_statistics"].items():
            if "num_rows" in stats and "num_columns" in stats:
                stats_summary.append(
                    f"{table_name}: {stats['num_rows']} rows Ã— {stats['num_columns']} columns"
                )
        if stats_summary:
            summary_parts.append(f"\nTable Sizes:\n" + "\n".join(stats_summary))

    return "\n".join(summary_parts)
