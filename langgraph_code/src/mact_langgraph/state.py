"""
State definitions for MACT LangGraph implementation.

This module defines the state schema and data structures used throughout
the MACT agent graph execution.
"""

from typing import TypedDict, List, Dict, Any, Optional, Union
from dataclasses import dataclass, field
from enum import Enum
import json


class ActionType(Enum):
    """Types of actions the agent can take."""
    RETRIEVE = "Retrieve"
    CALCULATE = "Calculate"
    SEARCH = "Search"
    OPERATE = "Operate"
    FINISH = "Finish"


class RewardType(Enum):
    """Types of reward functions for action selection."""
    CONSISTENCY = "consistency"
    LLM = "llm"
    LOGP = "logp"
    ROLLOUT = "rollout"
    COMBINED = "combined"


@dataclass
class TableInfo:
    """Information about a table in the dataset."""
    name: str
    columns: List[str]
    content: List[List[Any]]
    df_code: str = ""
    linear_representation: str = ""

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for serialization."""
        return {
            "name": self.name,
            "columns": self.columns,
            "content": self.content,
            "df_code": self.df_code,
            "linear_representation": self.linear_representation
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "TableInfo":
        """Create from dictionary."""
        return cls(
            name=data["name"],
            columns=data["columns"],
            content=data["content"],
            df_code=data.get("df_code", ""),
            linear_representation=data.get("linear_representation", "")
        )


@dataclass
class ActionCandidate:
    """A candidate action generated by the planner."""
    thought: str
    action: str
    action_type: ActionType
    argument: str
    score: float = 0.0
    raw_response: str = ""

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for serialization."""
        return {
            "thought": self.thought,
            "action": self.action,
            "action_type": self.action_type.value,
            "argument": self.argument,
            "score": self.score,
            "raw_response": self.raw_response
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "ActionCandidate":
        """Create from dictionary."""
        return cls(
            thought=data["thought"],
            action=data["action"],
            action_type=ActionType(data["action_type"]),
            argument=data["argument"],
            score=data.get("score", 0.0),
            raw_response=data.get("raw_response", "")
        )


class MACTState(TypedDict):
    """
    State schema for MACT LangGraph execution.

    This defines all the state variables that flow through the graph nodes.
    """

    # Input data
    question: str
    tables: List[Dict[str, Any]]  # Serialized TableInfo objects
    table_names: List[str]
    foreign_keys: List[str]
    primary_keys: List[str]
    context: str

    # Configuration
    plan_model: str
    code_model: str
    reward_type: str  # RewardType enum value
    plan_sample: int
    code_sample: int
    max_steps: int
    max_actual_steps: int
    use_pre_answer: bool
    answer_threshold: float
    long_table_op: str
    code_as_observation: bool
    without_tool: bool

    # Reasoning state
    current_step: int
    actual_step: int
    scratchpad: str

    # Current iteration data
    current_thought: str
    current_action: str
    current_observation: str
    current_action_type: str
    current_argument: str

    # Sampling and selection
    candidate_actions: List[Dict[str, Any]]  # Serialized ActionCandidate objects
    selected_action: Optional[Dict[str, Any]]  # Serialized ActionCandidate

    # Tool execution results
    tool_results: List[str]
    calculation_results: List[Union[str, float]]
    search_results: List[str]
    table_operations: List[str]

    # ðŸŽ¯ Fix #2: LLM observations from action planning (Original MACT style)
    llm_observations: List[str]

    # Answer tracking
    preliminary_answers: List[str]
    answer_frequencies: Dict[str, int]
    final_answer: Optional[str]
    confidence_score: float

    # Status flags
    is_finished: bool
    is_halted: bool
    has_error: bool
    error_message: str

    # History and logging
    step_history: List[Dict[str, str]]
    execution_log: List[str]

    # LLM token usage tracking
    total_input_tokens: int
    total_output_tokens: int


def create_initial_state(
    question: str,
    tables_data: List[Dict[str, Any]],
    table_names: List[str] = None,
    foreign_keys: List[str] = None,
    primary_keys: List[str] = None,
    context: str = "",
    config: Dict[str, Any] = None
) -> MACTState:
    """
    Create initial state for MACT graph execution.

    Args:
        question: The question to answer
        tables_data: List of table data dictionaries
        table_names: Names of the tables (optional)
        foreign_keys: Foreign key relationships (optional)
        primary_keys: Primary key information (optional)
        context: Additional context information
        config: Configuration dictionary

    Returns:
        Initial MACTState
    """
    if config is None:
        config = {}

    # Convert table data to TableInfo objects and serialize
    tables = []
    for i, table_data in enumerate(tables_data):
        if isinstance(table_data, dict) and "table_columns" in table_data:
            # MMQA format
            table_info = TableInfo(
                name=table_data.get("table_name", f"table_{i}"),
                columns=table_data["table_columns"],
                content=table_data["table_content"]
            )
        else:
            # Generic format
            table_info = TableInfo(
                name=f"table_{i}",
                columns=table_data.get("columns", []),
                content=table_data.get("content", [])
            )
        tables.append(table_info.to_dict())

    return MACTState(
        # Input data
        question=question,
        tables=tables,
        table_names=table_names or [f"table_{i}" for i in range(len(tables))],
        foreign_keys=foreign_keys or [],
        primary_keys=primary_keys or [],
        context=context,

        # Configuration
        plan_model=config.get("plan_model", "gpt-3.5-turbo"),
        code_model=config.get("code_model", "gpt-3.5-turbo"),
        reward_type=config.get("reward_type", "consistency"),
        plan_sample=config.get("plan_sample", 5),
        code_sample=config.get("code_sample", 5),
        max_steps=config.get("max_steps", 6),
        max_actual_steps=config.get("max_actual_steps", 6),
        use_pre_answer=config.get("use_pre_answer", True),
        answer_threshold=config.get("answer_threshold", 1.0),
        long_table_op=config.get("long_table_op", "ignore"),
        code_as_observation=config.get("code_as_observation", False),
        without_tool=config.get("without_tool", False),

        # Reasoning state
        current_step=1,
        actual_step=1,
        scratchpad="",

        # Current iteration data
        current_thought="",
        current_action="",
        current_observation="",
        current_action_type="",
        current_argument="",

        # Sampling and selection
        candidate_actions=[],
        selected_action=None,

        # Tool execution results
        tool_results=[],
        calculation_results=[],
        search_results=[],
        table_operations=[],

        # LLM observations
        llm_observations=[],

        # Answer tracking
        preliminary_answers=[],
        answer_frequencies={},
        final_answer=None,
        confidence_score=0.0,

        # Status flags
        is_finished=False,
        is_halted=False,
        has_error=False,
        error_message="",

        # History and logging
        step_history=[],
        execution_log=[],

        # Token usage
        total_input_tokens=0,
        total_output_tokens=0
    )


def get_tables_from_state(state: MACTState) -> List[TableInfo]:
    """Extract TableInfo objects from state."""
    return [TableInfo.from_dict(table_data) for table_data in state["tables"]]


def get_candidates_from_state(state: MACTState) -> List[ActionCandidate]:
    """Extract ActionCandidate objects from state."""
    return [ActionCandidate.from_dict(candidate_data) for candidate_data in state["candidate_actions"]]


def get_selected_action_from_state(state: MACTState) -> Optional[ActionCandidate]:
    """Extract selected ActionCandidate from state."""
    if state["selected_action"] is None:
        return None
    return ActionCandidate.from_dict(state["selected_action"])


def update_state_with_candidates(state: MACTState, candidates: List[ActionCandidate]) -> MACTState:
    """Update state with new action candidates."""
    return {
        **state,
        "candidate_actions": [candidate.to_dict() for candidate in candidates]
    }


def update_state_with_selected_action(state: MACTState, action: ActionCandidate) -> MACTState:
    """Update state with selected action."""
    return {
        **state,
        "selected_action": action.to_dict(),
        "current_thought": action.thought,
        "current_action": action.action,
        "current_action_type": action.action_type.value,
        "current_argument": action.argument
    }